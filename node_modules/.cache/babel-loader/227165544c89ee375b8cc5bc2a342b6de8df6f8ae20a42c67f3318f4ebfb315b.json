{"ast":null,"code":"var _jsxFileName = \"C:\\\\Thuchanh\\\\Painter\\\\frontend\\\\src\\\\pages\\\\Home\\\\Home.js\",\n  _s = $RefreshSig$();\nimport styles from \"./Home.module.scss\";\nimport classNames from 'classnames/bind';\nimport undoAction from \"../../assets/icons/rotate-left-solid.svg\";\nimport redoAction from \"../../assets/icons/rotate-right-solid.svg\";\n\n// import { useUser } from '~/hook/UserContext';\n// import Konva from 'konva';\n// import { Stage, Layer, Rect, Text } from 'react-konva';\n\nimport { useEffect, useRef, useState } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst cx = classNames.bind(styles);\nfunction Home({\n  selectedTool,\n  brushWidth,\n  selectedColor,\n  width,\n  height,\n  isClear,\n  setIsClear\n}) {\n  _s();\n  const canvasRef = useRef(null);\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [prevMouseX, setPrevMouseX] = useState(null);\n  const [prevMouseY, setPrevMouseY] = useState(null);\n  const [snapshot, setSnapshot] = useState(null);\n  // const [shapes, setShapes] = useState([]); // Store drawn shapes\n  // const [selectedShape, setSelectedShape] = useState(null);\n\n  // const pathBackEnd = 'https://backendpainter-v1.onrender.com';\n  // const { userInfo, imgId } = useUser();\n  // const [imageData, setImageData] = useState(null);\n\n  // useEffect(() => {\n  //     const fetchData = async () =>{\n  //         try {\n  //             const response = await fetch (`${pathBackEnd}/${userInfo.user_id}/${imgId}`,{\n  //                 method: 'PUT',\n  //                 headers:{\n  //                     'Content-Type': 'application/json',\n  //                 },\n  //                 body: JSON.stringify({}),\n  //             });\n  //             if (response.ok){\n  //                 const data = await response.json();\n  //                 setImageData(data.image);\n  //             } else {\n  //                 console.error('Failed to fetch image');\n  //             }\n  //         } catch (error){\n  //             console.error('Error fetching image:',error);\n  //         }\n  //     }\n  //     fetchData();\n  // },[userInfo.user_id,imgId]);\n  const parseJwt = token => {\n    try {\n      const base64Url = token.split(\".\")[1];\n      const base64 = base64Url.replace(\"-\", \"+\").replace(\"_\", \"/\");\n      const decoded = JSON.parse(atob(base64));\n      return decoded;\n    } catch (e) {\n      console.error(\"Error parsing JWT:\", e);\n      return null;\n    }\n  };\n\n  // Usage\n  if (localStorage.getItem(\"token-user\")) {\n    var userData = parseJwt(localStorage.getItem(\"token-user\"));\n    // Now userData contains the decoded JWT payload\n  }\n\n  const undoStack = useRef([]);\n  const redoStack = useRef([]);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n    if (context) {\n      setCanvasBackground(context);\n      setSnapshot(context.getImageData(0, 0, canvas.width, canvas.height));\n    }\n    if (isClear) {\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      clearCanvas();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isClear]);\n  const setCanvasBackground = context => {\n    context.fillStyle = '#fff';\n    context.fillRect(0, 0, context.canvas.width, context.canvas.height);\n    context.fillStyle = selectedColor;\n  };\n  const saveCanvasState = context => {\n    const canvas = context.canvas;\n    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n    undoStack.current.push(imageData);\n    redoStack.current = []; // Clear the redoStack after saving a new state\n  };\n\n  const undo = () => {\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n    if (!context) return;\n    if (undoStack.current.length > 0) {\n      const lastState = undoStack.current.pop();\n      redoStack.current.push(context.getImageData(0, 0, canvas.width, canvas.height));\n      context.putImageData(lastState, 0, 0);\n    }\n  };\n  const redo = () => {\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n    if (!context) return;\n    if (redoStack.current.length > 0) {\n      const nextState = redoStack.current.pop();\n      undoStack.current.push(context.getImageData(0, 0, canvas.width, canvas.height));\n      context.putImageData(nextState, 0, 0);\n    }\n  };\n  const startDraw = e => {\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n    if (!context) return;\n    setIsDrawing(true);\n    setIsClear(false);\n    setPrevMouseX(e.nativeEvent.offsetX);\n    setPrevMouseY(e.nativeEvent.offsetY);\n    saveCanvasState(context);\n    context.beginPath();\n    context.lineCap = 'round';\n    context.strokeStyle = selectedColor;\n    context.lineWidth = brushWidth;\n    setSnapshot(context.getImageData(0, 0, canvas.width, canvas.height));\n  };\n  const drawing = e => {\n    if (!isDrawing) return;\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n    if (!context) return;\n    context.putImageData(snapshot, 0, 0);\n    if (selectedTool === 'brush' || selectedTool === 'eraser') {\n      context.strokeStyle = selectedTool === 'eraser' ? '#fff' : selectedColor;\n      // context.moveTo(prevMouseX, prevMouseY);\n      context.lineTo(e.nativeEvent.offsetX, e.nativeEvent.offsetY);\n      context.stroke();\n    } else if (selectedTool === 'line') {\n      drawLine(context, e);\n    } else if (selectedTool === 'rectangle') {\n      drawRect(context, e);\n    } else if (selectedTool === 'triangle') {\n      drawTriangle(context, e);\n    } else if (selectedTool === 'circle') {\n      drawCircle(context, e);\n    } else if (selectedTool === 'fill') {\n      floodFill(context, getFillColor());\n    }\n  };\n  const stopDrawing = () => {\n    setIsDrawing(false);\n    updateSnapshot();\n  };\n  const drawLine = (context, e) => {\n    context.beginPath();\n    context.moveTo(prevMouseX, prevMouseY);\n    context.lineTo(e.nativeEvent.offsetX, e.nativeEvent.offsetY);\n    context.stroke();\n  };\n  const drawRect = (context, e) => {\n    const startX = Math.min(prevMouseX, e.nativeEvent.offsetX);\n    const startY = Math.min(prevMouseY, e.nativeEvent.offsetY);\n    const width = Math.abs(prevMouseX - e.nativeEvent.offsetX);\n    const height = Math.abs(prevMouseY - e.nativeEvent.offsetY);\n    context.strokeStyle = selectedColor;\n    context.strokeRect(startX, startY, width, height);\n  };\n  const drawTriangle = (context, e) => {\n    context.beginPath();\n    context.moveTo(prevMouseX, prevMouseY);\n    context.lineTo(e.nativeEvent.offsetX, e.nativeEvent.offsetY);\n    context.lineTo(prevMouseX * 2 - e.nativeEvent.offsetX, e.nativeEvent.offsetY);\n    context.closePath();\n    context.stroke();\n  };\n  const drawCircle = (context, e) => {\n    context.beginPath();\n    let radius = Math.sqrt(Math.pow(prevMouseX - e.nativeEvent.offsetX, 2) + Math.pow(prevMouseY - e.nativeEvent.offsetY, 2));\n    context.arc(prevMouseX, prevMouseY, radius, 0, 2 * Math.PI);\n    context.stroke();\n  };\n\n  // ------------Fill color----------------------------------\n  const floodFill = () => {\n    console.log('Flood Fill called');\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n    const targetColor = getPixel(imageData, prevMouseX, prevMouseY);\n    const fillColor = getFillColor();\n    console.log('Target Color:', targetColor);\n    console.log('Fill Color:', fillColor);\n    if (!colorsMatch(targetColor, fillColor, 30)) {\n      fillPixel(imageData, prevMouseX, prevMouseY, targetColor, fillColor);\n      context.putImageData(imageData, 0, 0);\n    }\n  };\n  const getPixel = (imageData, x, y) => {\n    const index = (y * imageData.width + x) * 4;\n    return [imageData.data[index],\n    // Red component\n    imageData.data[index + 1],\n    // Green component\n    imageData.data[index + 2],\n    // Blue component\n    imageData.data[index + 3] // Alpha component\n    ];\n  };\n\n  const colorsMatch = (color1, color2) => {\n    return color1[0] === color2[0] && color1[1] === color2[1] && color1[2] === color2[2] && color1[3] === color2[3];\n  };\n  const fillPixel = (imageData, x, y, targetColor, fillColor) => {\n    // const index = (y * imageData.width + x) * 4;\n    const imageDataArray = imageData.data;\n    const queue = [];\n    queue.push([x, y]);\n    while (queue.length > 0) {\n      const [pixelX, pixelY] = queue.shift();\n      const pixelIndex = (pixelY * imageData.width + pixelX) * 4;\n      const pixelColor = [imageDataArray[pixelIndex],\n      // Red component\n      imageDataArray[pixelIndex + 1],\n      // Green component\n      imageDataArray[pixelIndex + 2],\n      // Blue component\n      imageDataArray[pixelIndex + 3] // Alpha component\n      ];\n\n      if (colorsMatch(pixelColor, targetColor)) {\n        imageDataArray[pixelIndex] = fillColor[0];\n        imageDataArray[pixelIndex + 1] = fillColor[1];\n        imageDataArray[pixelIndex + 2] = fillColor[2];\n        imageDataArray[pixelIndex + 3] = fillColor[3];\n        if (pixelX > 0) {\n          queue.push([pixelX - 1, pixelY]);\n        }\n        if (pixelX < imageData.width - 1) {\n          queue.push([pixelX + 1, pixelY]);\n        }\n        if (pixelY > 0) {\n          queue.push([pixelX, pixelY - 1]);\n        }\n        if (pixelY < imageData.height - 1) {\n          queue.push([pixelX, pixelY + 1]);\n        }\n      }\n    }\n  };\n  const getFillColor = () => {\n    const colorString = selectedColor.toLowerCase();\n    // Check for color names or hexadecimal format\n    const namedColor = nameToRGB(colorString);\n    if (namedColor) {\n      return namedColor;\n    }\n    // Check for RGB format\n    const rgbRegex = /^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/;\n    const rgbMatch = colorString.match(rgbRegex);\n    if (rgbMatch) {\n      const red = parseInt(rgbMatch[1], 10);\n      const green = parseInt(rgbMatch[2], 10);\n      const blue = parseInt(rgbMatch[3], 10);\n      if (!isNaN(red) && !isNaN(green) && !isNaN(blue) && red >= 0 && red <= 255 && green >= 0 && green <= 255 && blue >= 0 && blue <= 255) {\n        return [red, green, blue, 255];\n      }\n    }\n    // Check for hexadecimal format\n    const hexRegex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/;\n    const hexMatch = colorString.match(hexRegex);\n    if (hexMatch) {\n      const red = parseInt(hexMatch[1], 16);\n      const green = parseInt(hexMatch[2], 16);\n      const blue = parseInt(hexMatch[3], 16);\n      if (!isNaN(red) && !isNaN(green) && !isNaN(blue)) {\n        return [red, green, blue, 255];\n      }\n    }\n    // If the colorString doesn't match any expected format, return a default color (black) with a default alpha value of 255 (fully opaque)\n    return [0, 0, 0, 255];\n  };\n  // Helper function to convert color names to RGB\n  const nameToRGB = colorName => {\n    const namedColors = {\n      grey: [128, 128, 128, 255]\n      // Add more named colors as needed\n    };\n\n    const normalizedColorName = colorName.toLowerCase();\n    if (namedColors[normalizedColorName]) {\n      return namedColors[normalizedColorName];\n    }\n    return null;\n  };\n  // -------------------------------------------------------\n  const updateSnapshot = () => {\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n    if (context) setSnapshot(context.getImageData(0, 0, canvas.width, canvas.height));\n  };\n  const clearCanvas = () => {\n    const canvas = canvasRef.current;\n    const context = canvas.getContext('2d');\n    if (!context) return;\n    //Clear Canvas\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    setCanvasBackground(context);\n  };\n  return /*#__PURE__*/_jsxDEV(\"section\", {\n    className: cx('drawing-board'),\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: cx('actions'),\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        className: cx(styles['button'], {\n          [styles['disabled-button']]: undoStack.current.length === 0\n        }),\n        onClick: undo,\n        children: [' ', /*#__PURE__*/_jsxDEV(\"img\", {\n          src: undoAction,\n          alt: \"undo\",\n          className: cx('items')\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 359,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 354,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: cx(styles['button'], {\n          [styles['disabled-button']]: redoStack.current.length === 0\n        }),\n        onClick: redo,\n        children: [' ', /*#__PURE__*/_jsxDEV(\"img\", {\n          src: redoAction,\n          alt: \"redo\",\n          className: cx('items')\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 366,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 361,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 353,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      id: \"myCanvas\",\n      ref: canvasRef,\n      width: width,\n      height: height,\n      onMouseDown: startDraw,\n      onMouseMove: drawing,\n      onMouseUp: stopDrawing,\n      onMouseLeave: stopDrawing\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 369,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 352,\n    columnNumber: 9\n  }, this);\n}\n_s(Home, \"N9BMSCkWi4oHdm+RD497VKRdG6Y=\");\n_c = Home;\nexport default Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");","map":{"version":3,"names":["styles","classNames","undoAction","redoAction","useEffect","useRef","useState","jsxDEV","_jsxDEV","cx","bind","Home","selectedTool","brushWidth","selectedColor","width","height","isClear","setIsClear","_s","canvasRef","isDrawing","setIsDrawing","prevMouseX","setPrevMouseX","prevMouseY","setPrevMouseY","snapshot","setSnapshot","parseJwt","token","base64Url","split","base64","replace","decoded","JSON","parse","atob","e","console","error","localStorage","getItem","userData","undoStack","redoStack","canvas","current","context","getContext","setCanvasBackground","getImageData","clearCanvas","fillStyle","fillRect","saveCanvasState","imageData","push","undo","length","lastState","pop","putImageData","redo","nextState","startDraw","nativeEvent","offsetX","offsetY","beginPath","lineCap","strokeStyle","lineWidth","drawing","lineTo","stroke","drawLine","drawRect","drawTriangle","drawCircle","floodFill","getFillColor","stopDrawing","updateSnapshot","moveTo","startX","Math","min","startY","abs","strokeRect","closePath","radius","sqrt","pow","arc","PI","log","targetColor","getPixel","fillColor","colorsMatch","fillPixel","x","y","index","data","color1","color2","imageDataArray","queue","pixelX","pixelY","shift","pixelIndex","pixelColor","colorString","toLowerCase","namedColor","nameToRGB","rgbRegex","rgbMatch","match","red","parseInt","green","blue","isNaN","hexRegex","hexMatch","colorName","namedColors","grey","normalizedColorName","clearRect","className","children","onClick","src","alt","fileName","_jsxFileName","lineNumber","columnNumber","id","ref","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","_c","$RefreshReg$"],"sources":["C:/Thuchanh/Painter/frontend/src/pages/Home/Home.js"],"sourcesContent":["import styles from './Home.module.scss';\nimport classNames from 'classnames/bind';\nimport undoAction from '~/assets/icons/rotate-left-solid.svg';\nimport redoAction from '~/assets/icons/rotate-right-solid.svg';\n\n// import { useUser } from '~/hook/UserContext';\n// import Konva from 'konva';\n// import { Stage, Layer, Rect, Text } from 'react-konva';\n\nimport { useEffect, useRef, useState } from 'react';\n\nconst cx = classNames.bind(styles);\n\nfunction Home({ selectedTool, brushWidth, selectedColor, width, height, isClear, setIsClear }) {\n    const canvasRef = useRef(null);\n\n    const [isDrawing, setIsDrawing] = useState(false);\n    const [prevMouseX, setPrevMouseX] = useState(null);\n    const [prevMouseY, setPrevMouseY] = useState(null);\n    const [snapshot, setSnapshot] = useState(null);\n    // const [shapes, setShapes] = useState([]); // Store drawn shapes\n    // const [selectedShape, setSelectedShape] = useState(null);\n\n    // const pathBackEnd = 'https://backendpainter-v1.onrender.com';\n    // const { userInfo, imgId } = useUser();\n    // const [imageData, setImageData] = useState(null);\n\n    // useEffect(() => {\n    //     const fetchData = async () =>{\n    //         try {\n    //             const response = await fetch (`${pathBackEnd}/${userInfo.user_id}/${imgId}`,{\n    //                 method: 'PUT',\n    //                 headers:{\n    //                     'Content-Type': 'application/json',\n    //                 },\n    //                 body: JSON.stringify({}),\n    //             });\n    //             if (response.ok){\n    //                 const data = await response.json();\n    //                 setImageData(data.image);\n    //             } else {\n    //                 console.error('Failed to fetch image');\n    //             }\n    //         } catch (error){\n    //             console.error('Error fetching image:',error);\n    //         }\n    //     }\n    //     fetchData();\n    // },[userInfo.user_id,imgId]);\n    const parseJwt = (token) => {\n        try {\n          const base64Url = token.split(\".\")[1];\n          const base64 = base64Url.replace(\"-\", \"+\").replace(\"_\", \"/\");\n          const decoded = JSON.parse(atob(base64));\n          return decoded;\n        } catch (e) {\n          console.error(\"Error parsing JWT:\", e);\n          return null;\n        }\n      };\n      \n      // Usage\n      if (localStorage.getItem(\"token-user\")) {\n        var userData = parseJwt(localStorage.getItem(\"token-user\"));\n        // Now userData contains the decoded JWT payload\n      }\n    const undoStack = useRef([]);\n    const redoStack = useRef([]);\n\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        const context = canvas.getContext('2d');\n\n        if (context) {\n            setCanvasBackground(context);\n            setSnapshot(context.getImageData(0, 0, canvas.width, canvas.height));\n        }\n        if (isClear) {\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n            clearCanvas();\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [isClear]);\n\n    const setCanvasBackground = (context) => {\n        context.fillStyle = '#fff';\n        context.fillRect(0, 0, context.canvas.width, context.canvas.height);\n        context.fillStyle = selectedColor;\n    };\n\n    const saveCanvasState = (context) => {\n        const canvas = context.canvas;\n        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n        undoStack.current.push(imageData);\n        redoStack.current = []; // Clear the redoStack after saving a new state\n    };\n\n    const undo = () => {\n        const canvas = canvasRef.current;\n        const context = canvas.getContext('2d');\n        if (!context) return;\n\n        if (undoStack.current.length > 0) {\n            const lastState = undoStack.current.pop();\n            redoStack.current.push(context.getImageData(0, 0, canvas.width, canvas.height));\n            context.putImageData(lastState, 0, 0);\n        }\n    };\n\n    const redo = () => {\n        const canvas = canvasRef.current;\n        const context = canvas.getContext('2d');\n        if (!context) return;\n\n        if (redoStack.current.length > 0) {\n            const nextState = redoStack.current.pop();\n            undoStack.current.push(context.getImageData(0, 0, canvas.width, canvas.height));\n            context.putImageData(nextState, 0, 0);\n        }\n    };\n\n    const startDraw = (e) => {\n        const canvas = canvasRef.current;\n        const context = canvas.getContext('2d');\n        if (!context) return;\n\n        setIsDrawing(true);\n        setIsClear(false);\n        setPrevMouseX(e.nativeEvent.offsetX);\n        setPrevMouseY(e.nativeEvent.offsetY);\n        saveCanvasState(context);\n\n        context.beginPath();\n        context.lineCap = 'round';\n        context.strokeStyle = selectedColor;\n        context.lineWidth = brushWidth;\n        setSnapshot(context.getImageData(0, 0, canvas.width, canvas.height));\n    };\n\n    const drawing = (e) => {\n        if (!isDrawing) return;\n        const canvas = canvasRef.current;\n        const context = canvas.getContext('2d');\n        if (!context) return;\n\n        context.putImageData(snapshot, 0, 0);\n\n        if (selectedTool === 'brush' || selectedTool === 'eraser') {\n            context.strokeStyle = selectedTool === 'eraser' ? '#fff' : selectedColor;\n            // context.moveTo(prevMouseX, prevMouseY);\n            context.lineTo(e.nativeEvent.offsetX, e.nativeEvent.offsetY);\n            context.stroke();\n        } else if (selectedTool === 'line') {\n            drawLine(context, e);\n        } else if (selectedTool === 'rectangle') {\n            drawRect(context, e);\n        } else if (selectedTool === 'triangle') {\n            drawTriangle(context, e);\n        } else if (selectedTool === 'circle') {\n            drawCircle(context, e);\n        } else if (selectedTool === 'fill') {\n            floodFill(context, getFillColor());\n        }\n    };\n\n    const stopDrawing = () => {\n        setIsDrawing(false);\n        updateSnapshot();\n    };\n\n    const drawLine = (context, e) => {\n        context.beginPath();\n        context.moveTo(prevMouseX, prevMouseY);\n        context.lineTo(e.nativeEvent.offsetX, e.nativeEvent.offsetY);\n        context.stroke();\n    };\n\n    const drawRect = (context, e) => {\n        const startX = Math.min(prevMouseX, e.nativeEvent.offsetX);\n        const startY = Math.min(prevMouseY, e.nativeEvent.offsetY);\n        const width = Math.abs(prevMouseX - e.nativeEvent.offsetX);\n        const height = Math.abs(prevMouseY - e.nativeEvent.offsetY);\n\n        context.strokeStyle = selectedColor;\n        context.strokeRect(startX, startY, width, height);\n    };\n\n    const drawTriangle = (context, e) => {\n        context.beginPath();\n        context.moveTo(prevMouseX, prevMouseY);\n        context.lineTo(e.nativeEvent.offsetX, e.nativeEvent.offsetY);\n        context.lineTo(prevMouseX * 2 - e.nativeEvent.offsetX, e.nativeEvent.offsetY);\n        context.closePath();\n        context.stroke();\n    };\n\n    const drawCircle = (context, e) => {\n        context.beginPath();\n        let radius = Math.sqrt(\n            Math.pow(prevMouseX - e.nativeEvent.offsetX, 2) + Math.pow(prevMouseY - e.nativeEvent.offsetY, 2),\n        );\n        context.arc(prevMouseX, prevMouseY, radius, 0, 2 * Math.PI);\n        context.stroke();\n    };\n\n    // ------------Fill color----------------------------------\n    const floodFill = () => {\n        console.log('Flood Fill called');\n        const canvas = canvasRef.current;\n        const context = canvas.getContext('2d');\n\n        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n        const targetColor = getPixel(imageData, prevMouseX, prevMouseY);\n        const fillColor = getFillColor();\n\n        console.log('Target Color:', targetColor);\n        console.log('Fill Color:', fillColor);\n\n        if (!colorsMatch(targetColor, fillColor, 30)) {\n            fillPixel(imageData, prevMouseX, prevMouseY, targetColor, fillColor);\n            context.putImageData(imageData, 0, 0);\n        }\n    };\n\n    const getPixel = (imageData, x, y) => {\n        const index = (y * imageData.width + x) * 4;\n        return [\n            imageData.data[index], // Red component\n            imageData.data[index + 1], // Green component\n            imageData.data[index + 2], // Blue component\n            imageData.data[index + 3], // Alpha component\n        ];\n    };\n    const colorsMatch = (color1, color2) => {\n        return color1[0] === color2[0] && color1[1] === color2[1] && color1[2] === color2[2] && color1[3] === color2[3];\n    };\n\n    const fillPixel = (imageData, x, y, targetColor, fillColor) => {\n        // const index = (y * imageData.width + x) * 4;\n        const imageDataArray = imageData.data;\n\n        const queue = [];\n        queue.push([x, y]);\n\n        while (queue.length > 0) {\n            const [pixelX, pixelY] = queue.shift();\n            const pixelIndex = (pixelY * imageData.width + pixelX) * 4;\n            const pixelColor = [\n                imageDataArray[pixelIndex], // Red component\n                imageDataArray[pixelIndex + 1], // Green component\n                imageDataArray[pixelIndex + 2], // Blue component\n                imageDataArray[pixelIndex + 3], // Alpha component\n            ];\n\n            if (colorsMatch(pixelColor, targetColor)) {\n                imageDataArray[pixelIndex] = fillColor[0];\n                imageDataArray[pixelIndex + 1] = fillColor[1];\n                imageDataArray[pixelIndex + 2] = fillColor[2];\n                imageDataArray[pixelIndex + 3] = fillColor[3];\n\n                if (pixelX > 0) {\n                    queue.push([pixelX - 1, pixelY]);\n                }\n                if (pixelX < imageData.width - 1) {\n                    queue.push([pixelX + 1, pixelY]);\n                }\n                if (pixelY > 0) {\n                    queue.push([pixelX, pixelY - 1]);\n                }\n                if (pixelY < imageData.height - 1) {\n                    queue.push([pixelX, pixelY + 1]);\n                }\n            }\n        }\n    };\n\n    const getFillColor = () => {\n        const colorString = selectedColor.toLowerCase();\n        // Check for color names or hexadecimal format\n        const namedColor = nameToRGB(colorString);\n        if (namedColor) {\n            return namedColor;\n        }\n        // Check for RGB format\n        const rgbRegex = /^rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)$/;\n        const rgbMatch = colorString.match(rgbRegex);\n        if (rgbMatch) {\n            const red = parseInt(rgbMatch[1], 10);\n            const green = parseInt(rgbMatch[2], 10);\n            const blue = parseInt(rgbMatch[3], 10);\n\n            if (\n                !isNaN(red) &&\n                !isNaN(green) &&\n                !isNaN(blue) &&\n                red >= 0 &&\n                red <= 255 &&\n                green >= 0 &&\n                green <= 255 &&\n                blue >= 0 &&\n                blue <= 255\n            ) {\n                return [red, green, blue, 255];\n            }\n        }\n        // Check for hexadecimal format\n        const hexRegex = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/;\n        const hexMatch = colorString.match(hexRegex);\n        if (hexMatch) {\n            const red = parseInt(hexMatch[1], 16);\n            const green = parseInt(hexMatch[2], 16);\n            const blue = parseInt(hexMatch[3], 16);\n\n            if (!isNaN(red) && !isNaN(green) && !isNaN(blue)) {\n                return [red, green, blue, 255];\n            }\n        }\n        // If the colorString doesn't match any expected format, return a default color (black) with a default alpha value of 255 (fully opaque)\n        return [0, 0, 0, 255];\n    };\n    // Helper function to convert color names to RGB\n    const nameToRGB = (colorName) => {\n        const namedColors = {\n            grey: [128, 128, 128, 255],\n            // Add more named colors as needed\n        };\n\n        const normalizedColorName = colorName.toLowerCase();\n        if (namedColors[normalizedColorName]) {\n            return namedColors[normalizedColorName];\n        }\n\n        return null;\n    };\n    // -------------------------------------------------------\n    const updateSnapshot = () => {\n        const canvas = canvasRef.current;\n        const context = canvas.getContext('2d');\n        if (context) setSnapshot(context.getImageData(0, 0, canvas.width, canvas.height));\n    };\n\n    const clearCanvas = () => {\n        const canvas = canvasRef.current;\n        const context = canvas.getContext('2d');\n        if (!context) return;\n        //Clear Canvas\n        context.clearRect(0, 0, canvas.width, canvas.height);\n        setCanvasBackground(context);\n    };\n\n    return (\n        <section className={cx('drawing-board')}>\n            <div className={cx('actions')}>\n                <button\n                    className={cx(styles['button'], { [styles['disabled-button']]: undoStack.current.length === 0 })}\n                    onClick={undo}\n                >\n                    {' '}\n                    <img src={undoAction} alt=\"undo\" className={cx('items')} />\n                </button>\n                <button\n                    className={cx(styles['button'], { [styles['disabled-button']]: redoStack.current.length === 0 })}\n                    onClick={redo}\n                >\n                    {' '}\n                    <img src={redoAction} alt=\"redo\" className={cx('items')} />\n                </button>\n            </div>\n            <canvas\n                id=\"myCanvas\"\n                ref={canvasRef}\n                width={width}\n                height={height}\n                onMouseDown={startDraw}\n                onMouseMove={drawing}\n                onMouseUp={stopDrawing}\n                onMouseLeave={stopDrawing}\n            ></canvas>\n        </section>\n    );\n}\n\nexport default Home;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}